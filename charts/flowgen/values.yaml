################################################################################
# Global options
################################################################################
global:
  # Global image configuration
  image:
    repository: ghcr.io/connve-labs/flowgen
    pullPolicy: IfNotPresent
    tag: "latest"

  # Global image pull secrets (optional)
  # Example:
  # imagePullSecrets:
  #   - name: regcred
  imagePullSecrets: []

################################################################################
# Flowgen Worker options
################################################################################
flowgen-worker:
  enabled: true

  nameOverride: ""
  fullnameOverride: ""

  # Number of replicas (used when autoscaling is disabled)
  replicaCount: 3

  # Horizontal Pod Autoscaler
  autoscaling:
    enabled: false
    minReplicas: 3
    maxReplicas: 20
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  labels: {}

  podAnnotations: {}
    # Example: Enable Stakater Reloader for auto-restart on ConfigMap changes
    # Requires Stakater Reloader to be installed in the cluster
    # configmap.reloader.stakater.com/reload: "flows,config"

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 65534

  # Termination grace period must be >= preStop sleep duration
  terminationGracePeriodSeconds: 45

  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: true
    seccompProfile:
      type: RuntimeDefault

  # Lifecycle hooks for graceful shutdown during rollouts
  lifecycle:
    preStop:
      exec:
        # Sleep for 30 seconds to allow leader election lease to expire gracefully.
        # This prevents new pods from waiting the full lease duration (60s) during rollouts.
        # Adjust this value based on your lease_duration_secs setting.
        command: ["/bin/sh", "-c", "sleep 30"]

  service:
    type: ClusterIP
    port: 3000

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  # RBAC configuration
  rbac:
    create: true
    rules:
      - apiGroups: ["coordination.k8s.io"]
        resources: ["leases"]
        verbs: ["get", "list", "create", "update", "patch", "delete"]

  config:
    path: /etc/app/config.yaml

  # Environment variables passed to the container.
  # Also accessible in flow configs via {{env.VAR_NAME}}.
  # Example:
  # - name: RUST_LOG
  #   value: "info,async_nats=warn"
  env: []

  # Flow and resource configuration management.
  # Supports three deployment methods for managing flow and resource files.
  # Method 1: External ConfigMaps created via kustomize, kubectl, or GitOps tools (recommended for production).
  # Method 2: Inline values embedded directly in values.yaml (suitable for testing or small configurations).
  # Method 3: GitOps auto-generation where ArgoCD or Flux generates ConfigMaps from git directories.
  flows:
    # Reference existing ConfigMaps created externally via kustomize, kubectl, or GitOps tools.
    # All ConfigMaps in this array will be mounted to the same flows directory.
    # When set, this takes precedence over inline values and prevents auto-generation of ConfigMaps.
    # Each ConfigMap should contain flow YAML files as keys with their complete content as values.
    # Example:
    #   existingConfigMaps:
    #     - flows-salesforce
    #     - flows-cloudflare
    #     - flows-gcp
    existingConfigMaps: []

    # Inline flow definitions for pure Helm deployments without external ConfigMap management.
    # These values are only used when existingConfigMaps is empty.
    # Keys should represent the flow file path, and values should contain the complete YAML content.
    # Example:
    #   inline:
    #     category/flow1.yaml: |
    #       flow:
    #         name: flow1
    #         tasks:
    #           - generate:
    #               name: trigger
    inline: {}

  resources:
    # Reference existing ConfigMaps for resource files such as SQL queries or scripts.
    # All ConfigMaps in this array will be mounted to the same resources directory.
    # When set, this takes precedence over inline values and prevents auto-generation of ConfigMaps.
    # Each ConfigMap should contain resource files as keys with their complete content as values.
    # Example:
    #   existingConfigMaps:
    #     - resources-sql
    #     - resources-scripts
    existingConfigMaps: []

    # Inline resource definitions for pure Helm deployments without external ConfigMap management.
    # These values are only used when existingConfigMaps is empty.
    # Keys should represent the resource filename, and values should contain the complete file content.
    # Example:
    #   inline:
    #     query1.sql: |
    #       SELECT * FROM table1
    inline: {}

  volumes:
    config:
      enabled: true
      configMapName: config
      mountPath: /etc/app
    flows:
      enabled: true
      mountPath: /etc/app/flows
    resources:
      enabled: true
      mountPath: /etc/app/resources
    # Secrets - user must configure these as needed.
    # Example:
    # natsCredentials:
    #   enabled: true
    #   secretName: "my-nats-secret"
    #   mountPath: /etc/nats
    # sfdcCredentials:
    #   enabled: true
    #   secretName: "my-sfdc-secret"
    #   mountPath: /etc/sfdc
    # gcpCredentials:
    #   enabled: true
    #   secretName: "my-gcp-secret"
    #   mountPath: /etc/gcp

  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 512Mi
    # requests:
    #   cpu: 250m
    #   memory: 256Mi

  nodeSelector: {}
  tolerations: []
  affinity: {}
